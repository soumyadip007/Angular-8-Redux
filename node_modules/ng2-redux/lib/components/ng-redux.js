"use strict";
var redux_1 = require('redux');
var Observable_1 = require('rxjs/Observable');
var BehaviorSubject_1 = require('rxjs/BehaviorSubject');
require('rxjs/add/operator/map');
require('rxjs/add/operator/filter');
require('rxjs/add/observable/from');
require('rxjs/add/operator/distinctUntilChanged');
require('rxjs/add/operator/switchMap');
var type_checks_1 = require('../utils/type-checks');
var omit_1 = require('../utils/omit');
var invariant_1 = require('../utils/invariant');
var get_in_1 = require('../utils/get-in');
var VALID_SELECTORS = ['string', 'string[]', 'number', 'symbol', 'function'];
var ERROR_MESSAGE = "Expected selector to be one of:\n    " + VALID_SELECTORS.join(',') + ". Instead recieved %s";
var checkSelector = function (s) { return VALID_SELECTORS.indexOf(typeof s, 0) >= 0 ||
    Array.isArray(s); };
var NgRedux = (function () {
    /**
     * Creates an instance of NgRedux.
     */
    function NgRedux(ngZone) {
        var _this = this;
        this.ngZone = ngZone;
        this._store = null;
        this._store$ = null;
        /**
         * Get the current state of the application
         * @returns {RootState} the application state
         */
        this.getState = function () {
            return _this._store.getState();
        };
        /**
         * Subscribe to the Redux store changes
         *
         * @param {() => void} listener callback to invoke when the state is updated
         * @returns a function to unsubscribe
         */
        this.subscribe = function (listener) {
            return _this._store.subscribe(listener);
        };
        /**
        * Replaces the reducer currently used by the store to calculate the state.
        *
        * You might need this if your app implements code splitting and you want to
        * load some of the reducers dynamically. You might also need this if you
        * implement a hot reloading mechanism for Redux.
        *
        * @param nextReducer The reducer for the store to use instead.
        */
        this.replaceReducer = function (nextReducer) {
            return _this._store.replaceReducer(nextReducer);
        };
        /**
         * Dispatch an action to Redux
         */
        this.dispatch = function (action) {
            invariant_1.invariant(!!_this._store, 'Dispatch failed: did you forget to configure your store? ' +
                'https://github.com/angular-redux/ng2-redux/blob/master/' +
                'README.md#quick-start');
            // Some apps dispatch actions from outside the angular zone; e.g. as
            // part of a 3rd-party callback, etc. When this happens, we need to
            // execute the dispatch in-zone or Angular2's UI won't update.
            return _this.ngZone.run(function () { return _this._store.dispatch(action); });
        };
        NgRedux.instance = this;
        this._store$ = new BehaviorSubject_1.BehaviorSubject(null)
            .filter(function (n) { return n !== null; })
            .switchMap(function (n) {
            return Observable_1.Observable.from(n);
        });
    }
    /**
     * configures a Redux store and allows NgRedux to observe and dispatch
     * to it.
     *
     * This should only be called once for the lifetime of your app, for
     * example in the constructor of your root component.
     *
     * @param {Redux.Reducer<RootState>} reducer Your app's root reducer
     * @param {RootState} initState Your app's initial state
     * @param {Redux.Middleware[]} middleware Optional Redux middlewares
     * @param {Redux.StoreEnhancer<RootState>[]} Optional Redux store enhancers
     */
    NgRedux.prototype.configureStore = function (reducer, initState, middleware, enhancers) {
        if (middleware === void 0) { middleware = []; }
        if (enhancers === void 0) { enhancers = []; }
        invariant_1.invariant(!this._store, 'Store already configured!');
        // Workaround for Redux issue #1935 - remove once Redux 3.6.0 is
        // released.
        var reTypedCompose = redux_1.compose;
        var finalCreateStore = reTypedCompose.apply(void 0, [redux_1.applyMiddleware.apply(void 0, middleware)].concat(enhancers))(redux_1.createStore);
        var store = finalCreateStore(reducer, initState);
        this.setStore(store);
    };
    /**
     * Accepts a Redux store, then sets it in NgRedux and
     * allows NgRedux to observe and dispatch to it.
     *
     * This should only be called once for the lifetime of your app, for
     * example in the constructor of your root component. If configureStore
     * has been used this cannot be used.
     *
     * @param {Redux.Store} store Your app's store
     */
    NgRedux.prototype.provideStore = function (store) {
        invariant_1.invariant(!this._store, 'Store already configured!');
        this.setStore(store);
    };
    ;
    /**
     * Select a slice of state to expose as an observable.
     *
     * @template S
     * @param { PropertySelector |
     *  PathSelector |
     *  FunctionSelector<RootState, S>}
     * selector key or function to select a part of the state
     * @param { Comparator } [comparer] Optional
     * comparison function called to test if an item is distinct
     * from the previous item in the source.
     *
     * @returns {Observable<S>} an Observable that emits items from the
     * source Observable with distinct values.
     */
    NgRedux.prototype.select = function (selector, comparator) {
        if (!selector) {
            return this
                ._store$
                .distinctUntilChanged(comparator);
        }
        invariant_1.invariant(checkSelector(selector), ERROR_MESSAGE, selector);
        var result;
        var changedStore = this._store$.distinctUntilChanged();
        if (typeof selector === 'string' ||
            typeof selector === 'number' ||
            typeof selector === 'symbol') {
            result = changedStore
                .map(function (state) { return state[selector]; });
        }
        else if (Array.isArray(selector)) {
            result = changedStore
                .map(function (state) { return get_in_1.getIn(state, selector); });
        }
        else {
            result = changedStore
                .map(selector);
        }
        return result.distinctUntilChanged(comparator);
    };
    NgRedux.prototype.getStateSlice = function (state, mapStateToScope) {
        var slice = mapStateToScope(state);
        invariant_1.invariant(type_checks_1.isPlainObject(slice), '`mapStateToScope` must return an object. Instead received %s.', slice);
        return slice;
    };
    NgRedux.prototype.setStore = function (store) {
        this._store = store;
        this._store$.next(store);
        this._defaultMapStateToTarget = function () { return ({}); };
        this._defaultMapDispatchToTarget = function (dispatch) { return ({ dispatch: dispatch }); };
        var cleanedStore = omit_1.omit(store, [
            'dispatch',
            'getState',
            'subscribe',
            'replaceReducer']);
        Object.assign(this, cleanedStore);
    };
    return NgRedux;
}());
exports.NgRedux = NgRedux;
;
//# sourceMappingURL=ng-redux.js.map